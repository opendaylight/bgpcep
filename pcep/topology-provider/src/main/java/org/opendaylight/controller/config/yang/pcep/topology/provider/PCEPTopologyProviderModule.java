/*
 * Copyright (c) 2013 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */
/**
 * Generated file
 * <p>
 * Generated from: yang module name: config-pcep-topology-provider  yang module local name: pcep-topology-impl
 * Generated by: org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
 * Generated at: Mon Nov 18 21:08:29 CET 2013
 * <p>
 * Do not modify this file unless it is present under src/main directory
 */
package org.opendaylight.controller.config.yang.pcep.topology.provider;

import static org.opendaylight.bgpcep.pcep.topology.provider.PCEPTopologyDeployerImpl.NATIVE_TRANSPORT_NOT_AVAILABLE;
import static org.opendaylight.bgpcep.pcep.topology.provider.PCEPTopologyDeployerImpl.PCEP_TOPOLOGY_PROVIDER_BEAN;
import static org.opendaylight.bgpcep.pcep.topology.provider.PCEPTopologyDeployerImpl.getAddressString;

import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.net.InetAddresses;
import com.google.common.reflect.AbstractInvocationHandler;
import com.google.common.reflect.Reflection;
import io.netty.channel.epoll.Epoll;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.stream.Collectors;
import org.opendaylight.bgpcep.pcep.topology.provider.PCEPTopologyDeployer;
import org.opendaylight.bgpcep.programming.spi.InstructionScheduler;
import org.opendaylight.bgpcep.topology.DefaultTopologyReference;
import org.opendaylight.bgpcep.topology.TopologyReference;
import org.opendaylight.controller.config.api.JmxAttributeValidationException;
import org.opendaylight.controller.config.api.osgi.WaitingServiceTracker;
import org.opendaylight.protocol.concepts.KeyMapping;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev130715.IpAddress;
import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.controller.rfc2385.cfg.rev160324.Rfc2385Key;
import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.odl.pcep.topology.provider.config.rev170301.odl.pcep.topology.provider.odl.pcep.topology.provider.config.ClientBuilder;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.TopologyId;
import org.osgi.framework.BundleContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @deprecated
 */
public final class PCEPTopologyProviderModule extends
    org.opendaylight.controller.config.yang.pcep.topology.provider.AbstractPCEPTopologyProviderModule {
    private static final Logger LOG = LoggerFactory.getLogger(PCEPTopologyProviderModule.class);

    private static final String IS_NOT_SET = "is not set.";
    private BundleContext bundleContext;

    public PCEPTopologyProviderModule(final org.opendaylight.controller.config.api.ModuleIdentifier identifier,
        final org.opendaylight.controller.config.api.DependencyResolver dependencyResolver) {
        super(identifier, dependencyResolver);
    }

    public PCEPTopologyProviderModule(final org.opendaylight.controller.config.api.ModuleIdentifier identifier,
        final org.opendaylight.controller.config.api.DependencyResolver dependencyResolver,
        final PCEPTopologyProviderModule oldModule, final java.lang.AutoCloseable oldInstance) {
        super(identifier, dependencyResolver, oldModule, oldInstance);
    }

    private Optional<KeyMapping> contructKeys() {
        KeyMapping ret = null;
        final List<Client> clients = getClient();

        if (clients != null && !clients.isEmpty()) {
            ret = KeyMapping.getKeyMapping();
            for (final Client c : clients) {
                if (c.getAddress() == null) {
                    LOG.warn("Client {} does not have an address skipping it", c);
                    continue;
                }
                final Rfc2385Key rfc2385KeyPassword = c.getPassword();
                if (rfc2385KeyPassword != null && !rfc2385KeyPassword.getValue().isEmpty()) {
                    final String s = getAddressString(c.getAddress());
                    ret.put(InetAddresses.forString(s), rfc2385KeyPassword.getValue().getBytes(StandardCharsets.US_ASCII));
                }
            }
        }
        return Optional.fromNullable(ret);
    }

    @Override
    public void customValidation() {
        JmxAttributeValidationException.checkNotNull(getTopologyId(), IS_NOT_SET, topologyIdJmxAttribute);
        JmxAttributeValidationException.checkNotNull(getListenAddress(), IS_NOT_SET, listenAddressJmxAttribute);
        JmxAttributeValidationException.checkNotNull(getListenPort(), IS_NOT_SET, listenPortJmxAttribute);
        JmxAttributeValidationException.checkNotNull(getStatefulPlugin(), IS_NOT_SET, statefulPluginJmxAttribute);
        JmxAttributeValidationException.checkNotNull(getRpcTimeout(), IS_NOT_SET, rpcTimeoutJmxAttribute);

        final Optional<KeyMapping> keys = contructKeys();
        if (keys.isPresent()) {
            JmxAttributeValidationException.checkCondition(Epoll.isAvailable(), NATIVE_TRANSPORT_NOT_AVAILABLE,
                clientJmxAttribute);
        }
    }

    private InetAddress listenAddress() {
        final IpAddress a = getListenAddress();
        Preconditions.checkArgument(a.getIpv4Address() != null || a.getIpv6Address() != null,
            "Address %s not supported", a);
        if (a.getIpv4Address() != null) {
            return InetAddresses.forString(a.getIpv4Address().getValue());
        }
        return InetAddresses.forString(a.getIpv6Address().getValue());
    }

    @Override
    public java.lang.AutoCloseable createInstance() {
        final WaitingServiceTracker<PCEPTopologyDeployer> pcepcTopologyDeployerTracker =
            WaitingServiceTracker.create(PCEPTopologyDeployer.class, this.bundleContext);
        final PCEPTopologyDeployer pcepcTopologyDeployer = pcepcTopologyDeployerTracker
            .waitForService(WaitingServiceTracker.FIVE_MINUTES);

        final TopologyId topologyID = getTopologyId();
        final InstructionScheduler scheduler = getSchedulerDependency();
        final List<Client> clientList = getClient();
        pcepcTopologyDeployer.addRootRuntimeBeanRegistratorWrapper(topologyID, getRootRuntimeBeanRegistratorWrapper());
        try {
            pcepcTopologyDeployer.writeConfiguration(topologyID, scheduler.getInstructionID(), listenAddress(),
                getListenPort(), getRpcTimeout(), transformClientList(clientList)).get();
        } catch (final Exception e) {
            throw new IllegalStateException("Failed to instantiate provider", e);
        }

        final WaitingServiceTracker<DefaultTopologyReference> defaultTopologyReferenceTracker =
            WaitingServiceTracker.create(DefaultTopologyReference.class, this.bundleContext,
                "(" + PCEP_TOPOLOGY_PROVIDER_BEAN + "=" + topologyID.getValue() + ")");
        final DefaultTopologyReference defaultTopologyReference = defaultTopologyReferenceTracker
            .waitForService(WaitingServiceTracker.FIVE_MINUTES);

        return Reflection.newProxy(PcepTopologyProviderCloseable.class, new AbstractInvocationHandler() {
            @Override
            protected Object handleInvocation(final Object proxy, final Method method, final Object[] args) throws Throwable {
                if (method.getName().equals("close")) {
                    pcepcTopologyDeployer.removeConfiguration(topologyID);
                    pcepcTopologyDeployer.removeRootRuntimeBeanRegistratorWrapper(topologyID);
                    pcepcTopologyDeployerTracker.close();
                    defaultTopologyReferenceTracker.close();
                    return null;
                } else {
                    return method.invoke(defaultTopologyReference, args);
                }
            }
        });
    }

    List<org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.odl.pcep.topology.provider.config.rev170301
        .odl.pcep.topology.provider.odl.pcep.topology.provider.config.Client> transformClientList(final List<Client> clientList) {
        return clientList.stream().map(client -> new ClientBuilder().setAddress(client.getAddress())
            .setPassword(client.getPassword()).build()).collect(Collectors.toList());
    }

    void setBundleContext(final BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }

    private interface PcepTopologyProviderCloseable extends TopologyReference, AutoCloseable {

    }
}
